{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "158af8876ddc47b6bc0006b66fd3480c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Canvas(toolbar=Toolbar(toolitems=[('Home', 'Reset original view', 'home', 'home'), ('Back', 'Back to previous â€¦"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#Assuming that we already know the k vectors\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "%matplotlib widget\n",
    "np.seterr(all='raise') #raise warning as errors\n",
    "#kvector = np.array([[1,0,0],[0,1,0],[0,0,1]])\n",
    "kvector = np.array([[1.142813,0.659803,0.000000],[0.000000,1.319607,0.000000],[0.000000,0.00000,0.696044]]) #LMS\n",
    "#kvector = np.array([[1.559103,0.000000,-0.618180],[0.000000,1.55910,-0.618180],[0.000000,0.000000,1.236361]]) #122\n",
    "#kvector = np.array([[0.889869,-1.766472,0.180192],[0.000000,1.97795,0.180192],[0.000000,0.00000,1.151539]])\n",
    "#surface BZ\n",
    "dis = 2 #Distance between surface Bz gamma and Bulk BZ gamma: setting number\n",
    "direc = np.array([0,0,1]) #Fraction index under kvector basis\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def crossline(vector1:list,vector2:list):\n",
    "    #Return the crossing line of two planes with normal vectors 1 and 2.\n",
    "    if(abs(np.dot(vector1,vector2))==np.sqrt(np.dot(vector1,vector1)*np.dot(vector2,vector2))):\n",
    "        return np.array([0,0,0,0,0,0,0,0]) #Two planes are parrellel\n",
    "    #Vector 1 and 2 are normal vectors of two planes: just k vector): So the planes are vector*(x,y,z)==1/2|vector|^2\n",
    "    direct = np.cross(vector1,vector2) #The direction of the line\n",
    "    #Then we need to figure out how to find a point on the line. \n",
    "    norm_direct = np.cross(vector1,direct) #direction of a line // to the plane 1 and perpendicular to the line\n",
    "    #Then the line with direction norm_direct and passing point 1/2 vector1 must be in the plane 1 and perpendicular to the line\n",
    "    t = 0.5*(np.dot(vector2,vector2)-np.dot(vector1,vector2))/(np.dot(vector2,norm_direct))\n",
    "    #So the crossing point is t*norm_direct+0.5*vector1\n",
    "    return np.concatenate((direct,t*norm_direct+0.5*vector1,np.array([-100000,100000]))) #The first three index are the direction, 4-6 are the fixing points, last two are the range of t\n",
    "\n",
    "\n",
    "def cutrange(kvector,linevector):\n",
    "    flag1 = np.dot(kvector,linevector[6]*linevector[:3]+linevector[3:6])-0.5*np.dot(kvector,kvector)\n",
    "    flag2 = np.dot(kvector,linevector[7]*linevector[:3]+linevector[3:6])-0.5*np.dot(kvector,kvector)\n",
    "    \n",
    "    \n",
    "    if(flag1>0.0001 and flag2>0.0001):\n",
    "        return 0 #the line part is not in the first BZ, why return True doesn't work?\n",
    "    elif(flag1>0.0001 and flag2<=0.0001):\n",
    "        linevector[6] = (0.5*np.dot(kvector,kvector)-np.dot(kvector,linevector[3:6]))/(np.dot(kvector,linevector[:3]))\n",
    "    elif(flag1<=0.0001 and flag2>0.0001):\n",
    "        linevector[7] = (0.5*np.dot(kvector,kvector)-np.dot(kvector,linevector[3:6]))/(np.dot(kvector,linevector[:3]))\n",
    "    \n",
    "    return 1\n",
    "\n",
    "kvectors = []\n",
    "\n",
    "for i in [-1,0,1]:\n",
    "    for j in [-1,0,1]:\n",
    "        for k in [-1,0,1]:\n",
    "            if(i==0 and j==0 and k==0):\n",
    "                continue\n",
    "            kvectors.append(i*kvector[0]+j*kvector[1]+k*kvector[2])\n",
    "\n",
    "hs_lines = [] #High symmetry lines\n",
    "\n",
    "for i in range(len(kvectors)-1):\n",
    "    for j in range(i+1,len(kvectors)):\n",
    "        hs_line = crossline(kvectors[i],kvectors[j])\n",
    "        if(list(hs_line) == [0,0,0,0,0,0,0,0]):\n",
    "            continue\n",
    "        flag = 0\n",
    "        for k in range(len(kvectors)):\n",
    "            if(k!=i and k!=j):\n",
    "                try:\n",
    "                    if(not cutrange(kvectors[k],hs_line)):\n",
    "                        flag=1\n",
    "                        break\n",
    "                except:\n",
    "                    print(i,j,k,hs_line)\n",
    "        if(flag==0 and (hs_line[6]!=0 or hs_line[7]!=0)):\n",
    "            hs_lines.append(hs_line)\n",
    "#Now throw away those duplicate ones\n",
    "hs_lines_f = []\n",
    "for hs_line in hs_lines:\n",
    "    if(abs(hs_line[6]-hs_line[7])<0.00001):\n",
    "        continue\n",
    "    flag = 0\n",
    "    for i in hs_lines_f:\n",
    "        if(abs(np.dot(i[:3],hs_line[:3]))==np.sqrt(np.dot(i[:3],i[:3])*np.dot(hs_line[:3],hs_line[:3])) and (abs(np.dot(i[3:6]-hs_line[3:6],i[3:6]-hs_line[3:6]))<0.0001 or abs(np.dot(i[3:6]-hs_line[3:6],hs_line[:3]))==np.sqrt(np.dot(i[3:6]-hs_line[3:6],i[3:6]-hs_line[3:6])*np.dot(hs_line[:3],hs_line[:3])))):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_lines_f.append(hs_line)\n",
    "\n",
    "\n",
    "#High symmetry points\n",
    "hs_points = []\n",
    "for hs_line in hs_lines_f:\n",
    "    flag = 0\n",
    "    for point in hs_points:\n",
    "        if(abs(np.dot(point-(hs_line[6]*hs_line[:3]+hs_line[3:6]),point-(hs_line[6]*hs_line[:3]+hs_line[3:6])))<0.000001):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_points.append(hs_line[6]*hs_line[:3]+hs_line[3:6])\n",
    "    flag = 0\n",
    "    for point in hs_points:\n",
    "        if(abs(np.dot(point-(hs_line[7]*hs_line[:3]+hs_line[3:6]),point-(hs_line[7]*hs_line[:3]+hs_line[3:6])))<0.000001):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_points.append(hs_line[7]*hs_line[:3]+hs_line[3:6])\n",
    "\n",
    "hs_points = np.array(hs_points) \n",
    "\n",
    "#Surface BZ:\n",
    "\n",
    "direc_a=np.dot(direc,kvector)/np.sqrt(np.dot(np.dot(direc,kvector),np.dot(direc,kvector)))\n",
    "#So the projected surface is np.dot(direc_a,(x,y,z))=dis\n",
    "#projected bulk Gammas\n",
    "kvectors_pro = []\n",
    "kgamma_pro = dis*direc_a\n",
    "for kv in kvectors:\n",
    "    kv_pro = (dis-np.dot(kv,direc_a))*direc_a+kv\n",
    "    if(np.dot(kgamma_pro-kv_pro,kgamma_pro-kv_pro)<0.0001):\n",
    "        continue\n",
    "    flag = 0\n",
    "    for j in kvectors_pro:\n",
    "        if(np.dot(j-kv_pro,j-kv_pro)<0.0001):\n",
    "            flag=1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        kvectors_pro.append(kv_pro)\n",
    "\n",
    "def crossline2(kvector,kgamma):\n",
    "    slope = np.cross(kvector-kgamma,direc_a)\n",
    "    return np.concatenate((slope,0.5*(kvector+kgamma),np.array([-1000,1000])))\n",
    "\n",
    "def cutrange2(kvector,kgamma,linevector):\n",
    "    flag1 = np.dot(kvector-kgamma,linevector[6]*linevector[:3]+linevector[3:6])-0.5*np.dot(kvector-kgamma,kvector-kgamma)\n",
    "    flag2 = np.dot(kvector-kgamma,linevector[7]*linevector[:3]+linevector[3:6])-0.5*np.dot(kvector-kgamma,kvector-kgamma)\n",
    "    if(flag1>0.0001 and flag2>0.0001):\n",
    "        return 0 #the line part is not in the first BZ, \n",
    "    elif(flag1>0.0001 and flag2<=0.0001):\n",
    "        linevector[6] = (0.5*np.dot(kvector-kgamma,kvector-kgamma)-np.dot(kvector-kgamma,linevector[3:6]))/(np.dot(kvector-kgamma,linevector[:3]))\n",
    "    elif(flag1<=0.0001 and flag2>0.0001):\n",
    "        linevector[7] = (0.5*np.dot(kvector-kgamma,kvector-kgamma)-np.dot(kvector-kgamma,linevector[3:6]))/(np.dot(kvector-kgamma,linevector[:3]))\n",
    "    \n",
    "    return 1\n",
    "\n",
    "hs_lines_pro = []\n",
    "for kv in kvectors_pro:\n",
    "    hs_line = crossline2(kv,kgamma_pro)\n",
    "    flag = 0\n",
    "    for i in kvectors_pro:\n",
    "        if(np.dot(i-kv,i-kv)>0.00001):\n",
    "            if(not cutrange2(i,kgamma_pro,hs_line)):\n",
    "                flag =1\n",
    "                break\n",
    "    if(flag==0):\n",
    "        hs_lines_pro.append(hs_line)\n",
    "\n",
    "hs_lines_pro_f = []\n",
    "for hs_line in hs_lines_pro:\n",
    "    if(abs(hs_line[6]-hs_line[7])<0.00001):\n",
    "        continue\n",
    "    flag = 0\n",
    "    for i in hs_lines_pro_f:\n",
    "        if(abs(np.dot(i[:3],hs_line[:3]))==np.sqrt(np.dot(i[:3],i[:3])*np.dot(hs_line[:3],hs_line[:3])) and (abs(np.dot(i[3:6]-hs_line[3:6],i[3:6]-hs_line[3:6]))<0.0001 or abs(np.dot(i[3:6]-hs_line[3:6],hs_line[:3]))==np.sqrt(np.dot(i[3:6]-hs_line[3:6],i[3:6]-hs_line[3:6])*np.dot(hs_line[:3],hs_line[:3])))):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_lines_pro_f.append(hs_line)\n",
    "\n",
    "#High symmetry points\n",
    "hs_pro_points = []\n",
    "for hs_line in hs_lines_pro_f:\n",
    "    flag = 0\n",
    "    for point in hs_pro_points:\n",
    "        if(abs(np.dot(point-(hs_line[6]*hs_line[:3]+hs_line[3:6]),point-(hs_line[6]*hs_line[:3]+hs_line[3:6])))<0.000001):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_pro_points.append(hs_line[6]*hs_line[:3]+hs_line[3:6])\n",
    "    flag = 0\n",
    "    for point in hs_pro_points:\n",
    "        if(abs(np.dot(point-(hs_line[7]*hs_line[:3]+hs_line[3:6]),point-(hs_line[7]*hs_line[:3]+hs_line[3:6])))<0.000001):\n",
    "            flag = 1\n",
    "            break\n",
    "    if(flag==0):\n",
    "        hs_pro_points.append(hs_line[7]*hs_line[:3]+hs_line[3:6])\n",
    "\n",
    "hs_pro_points = np.array(hs_pro_points) \n",
    "\n",
    "\n",
    "\n",
    "x = hs_points[:,0]\n",
    "y = hs_points[:,1]\n",
    "z = hs_points[:,2]\n",
    "x_pro = hs_pro_points[:,0]\n",
    "y_pro = hs_pro_points[:,1]\n",
    "z_pro = hs_pro_points[:,2]\n",
    "\n",
    "\n",
    "\n",
    "fig = plt.figure()\n",
    "ax = Axes3D(fig)\n",
    "ax.scatter(x,y,z)\n",
    "ax.scatter(x_pro,y_pro,z_pro)\n",
    "for i in hs_lines_f:\n",
    "    start = i[6]*i[:3]+i[3:6]\n",
    "    end = i[7]*i[:3]+i[3:6]\n",
    "    ax.plot([start[0],end[0]],[start[1],end[1]],[start[2],end[2]])\n",
    "\n",
    "for i in hs_lines_pro_f:\n",
    "    start = i[6]*i[:3]+i[3:6]\n",
    "    end = i[7]*i[:3]+i[3:6]\n",
    "    ax.plot([start[0],end[0]],[start[1],end[1]],[start[2],end[2]])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
